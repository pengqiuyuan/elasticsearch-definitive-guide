
=== Java 虚拟机

你应该始终运行最新版本的 Java 虚拟机（ JVM），
除非 Elasticsearch 网站上另有说明。((("deployment", "Java Virtual Machine (JVM)")))((("JVM (Java Virtual Machine)")))((("Java Virtual Machine", see="JVM")))  Elasticsearch，
特别是 Lucene，是一个高要求的软件。Lucene 的单元测试和集成测试经常暴露出 JVM 本身的 bug。这些 bug 的范围从轻微的麻烦到严重段错误，所以，最好尽可能的使用最新版本的 JVM。

Java 7 强烈优先选择于 Java 6。Oracle 或者 OpenJDK 是可以接受的，它们在性能和稳定性也差不多。

如果你的应用程序是用 Java 编写并正在使用 transport 客户端或 node 客户端，请确保 JVM 运行你的应用程序是完全相同的服务器 JVM。
在 Elasticsearch 几个地方，使用 Java 的本地序列化（ IP 地址、异常等等）。不幸的是，Oracle 会更改序列化格式之间较小的版本，从而导致奇怪的错误。
这种情况很少见，但它是保持客户端和服务器之间 JVM 相同版本的最佳实践。

.请不要调整JVM设置
****
JVM 暴露出几十个（甚至数百）的设置、参数和配置。((("JVM (Java Virtual Machine)", "avoiding custom configuration"))) 它们允许你进行微调 JVM 几乎是每一个方面。

当遇到一个旋钮，它是人的本性，要打开它。我们恳求你压制这个本性，而 _不是_ 使用自定义 JVM 设置。Elasticsearch is
a complex piece of software, and the current JVM settings have been tuned
over years of real-world usage.

It is easy to start turning knobs, producing opaque effects that are hard to measure,
and eventually detune your cluster into a slow, unstable mess.  When debugging
clusters, the first step is often to remove all custom configurations.  About
half the time, this alone restores stability and performance.
****

=== Transport Client Versus Node Client

If you are using Java, you may wonder when to use the transport client versus the
node client.((("Java", "clients for Elasticsearch")))((("clients")))((("node client", "versus transport client")))((("transport client", "versus node client")))  As discussed at the beginning of the book, the transport client
acts as a communication layer between the cluster and your application.  It knows
the API and can automatically round-robin between nodes, sniff the cluster for you,
and more. But it is _external_ to the cluster, similar to the REST clients.

The node client, on the other hand, is actually a node within the cluster (but
does not hold data, and cannot become master).  Because it is a node, it knows
the entire cluster state (where all the nodes reside, which shards live in which
nodes, and so forth). This means it can execute APIs with one less network hop.

There are uses-cases for both clients:

- The transport client is ideal if you want to decouple your application from the
cluster.  For example, if your application quickly creates and destroys
connections to the cluster, a transport client is much "lighter" than a node client,
since it is not part of a cluster.
+
Similarly, if you need to create thousands of connections, you don't want to
have thousands of node clients join the cluster.  The TC will be a better choice.

- On the flipside, if you need only a few long-lived, persistent connection
objects to the cluster, a node client can be a bit more efficient since it knows
the cluster layout.  But it ties your application into the cluster, so it may
pose problems from a firewall perspective.

=== Configuration Management

If you use configuration management already (Puppet, Chef, Ansible), you can skip this tip.((("deployment", "configuration management")))((("configuration management")))

If you don't use configuration management tools yet, you should!  Managing
a handful of servers by `parallel-ssh` may work now, but it will become a nightmare
as you grow your cluster.  It is almost impossible to edit 30 configuration files
by hand without making a mistake.

Configuration management tools help make your cluster consistent by automating
the process of config changes.  It may take a little time to set up and learn,
but it will pay itself off handsomely over time.
