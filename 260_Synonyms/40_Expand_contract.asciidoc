[[synonyms-expand-or-contract]]
=== 扩展或收缩

在 <<synonym-formats>> 中，我们看到它是((("synonyms", "expanding or contracting")))可能的，通过 _简单扩展_ 、 _简单收缩_ 、或_通用扩展_ 以取代同义词。
我们将看看这一部分中的每种技术在本章的权衡舍取。

提示：本节仅处理单词同义词。多词同义词又增添了一层复杂性，在 <<multi-word-synonyms>> 中，我们将会讨论。

[[synonyms-expansion]]
==== 简单扩展

通过 _简单扩展_ ，((("synonyms", "expanding or contracting", "simple expansion")))((("simple expansion (synonyms)"))) 任何列出的同义词都可以扩展到 _所有_ 列出的同义词：

    "jump,hop,leap"

扩展可以应用在索引或查询的时候。每个方面都有优点
(⬆)︎ 和缺点 (⬇)︎。 何时使用归结为性能与灵活性。

[options="header",cols="h,d,d"]
|===================================================
|                   | 索引             | 查询

| 索引的大小        |
      ⬇︎ 大指标因为所有同义词必须被索引。|
      ⬆︎ 正常。

| 关联         |
      ⬇︎ 所有同义词都有相同的 IDF（参见 <<relevance-intro>>），这意味着更多常用的单词将会产生有相同的重量、不常用的单词。|
      ⬆︎ T每个同义词 IDF 将是正确的。

| 性能 |
      ⬆︎ 查询只需要找到查询字符串中指定单个词项。|
      ⬇︎ 对一个词项的查询重写来查找所有的同义词，从而降低性能。

| 灵活性       |
      ⬇︎ 同义词规则不能改变现有的文件。对于有影响的新规则，现有的文件都要重建。|
      ⬆︎ 同义词规则可以更新不需要索引文件。
|===================================================

[[synonyms-contraction]]
==== 简单收缩

_简单收缩_ ，映射一组 ((("synonyms", "expanding or contracting", "simple contraction")))((("simple contraction (synonyms)"))) 左侧的同义词到右边的一个单一值：

    "leap,hop => jump"

它必须使用在索引或者查询的时候，确保该查询词项映射到相同的单个值，并且在索引中存在。

这种方法相对于简单扩展方法有一些优点也有一些缺点相比：

索引的大小::

⬆︎ 索引大小是正常的，因为只有一个单一的词项索引。

关联::

⬇︎ 所有词项的 IDF 是一样的，所以你不能区分比较常用的词、不常用的单词。

性能::

⬆︎ 查询只需要在索引中找到单词的出现。

灵活性::
+
--

⬆︎ 新同义词可以添加到规则的左侧并在查询的时候使用。例如，我们想添加 `bound` 到先前指定的规则这个词。下面的规则将用于包含 `bound` 的查询或包含 `bound` 的新添加的文档的查询：

    "leap,hop,bound => jump"

但是我们可以扩大效果也可以考虑在 _现有_ 文档中包含 `bound` ，通过编写规则如下:

    "leap,hop,bound => jump,bound"

当你重建索引文件，你可以恢复到以前的规则来获得查询单个词项的性能优势。

--

[[synonyms-genres]]
==== 类型扩展

类型扩展是完全不同于简单收缩 ((("synonyms", "expanding or contracting", "genre expansion")))((("genre expansion (synonyms)"))) 或扩张，
并不是平等对待所有的同义词，类型的扩展扩大了词的意义，更为通用。以这些规则为例：

    "cat    => cat,pet",
    "kitten => kitten,cat,pet",
    "dog    => dog,pet"
    "puppy  => puppy,dog,pet"

通过在索引的时候使用类型扩展：

* 一个关于 `kitten` 的查询会发现关于 kittens 的文件。
* 查询一个 `cat` 会找到关于 kittens 和 cats 的文件。
* 一个 `pet` 的查询将发现有关的 kittens、cats、puppies、dogs 或者 pets 的文件。

另外，通过在查询时候的使用类型扩展，查询 `kitten` 将扩大到返回的文件，提到的 kittens、cats、puppies、dogs。

您也可以有两全其美的办法，通过在索引的时候扩展，以确保类型在索引中存在。然后，在查询的时候，
你可以选择不采用同义词（使 `kitten` 查询只返回 kittens 的文件）或采用同义词以匹配 kittens、cats、pets（包括犬品种）。

前面的示例规则，对 `kitten` 的 IDF 将是正确的，而 `cat` 和 `pet` 的 IDF 将人为地缩小了。然而, 这是对你有利的，对于 `kitten` 或 `cat` 或者 `pet` 的类型扩展查询将被排名， `kitten` 的文件最高，其次是 `cat` 的文件， `pet` 的文件将被排在最底部。
