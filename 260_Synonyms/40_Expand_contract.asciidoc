[[synonyms-expand-or-contract]]
=== 扩展或收缩

在 <<synonym-formats>>，我们看到它是 ((("synonyms", "expanding or contracting"))) 可能的，通过 _简单的扩展_ 、 _简单的收缩_ 、或_通用扩展_ 以取代同义词。
我们将看看这一部分中的每一个技术在本章的权衡舍取。

提示：本节仅处理单词同义词。多词同义词又增添了一层复杂性，在 <<multi-word-synonyms>> 中，我们将会讨论。

[[synonyms-expansion]]
==== 简单的扩展

通过 _简单的扩展_ ，((("synonyms", "expanding or contracting", "simple expansion")))((("simple expansion (synonyms)"))) 任何列出的同义词都可以扩展到 _所有_ 列出的同义词：

    "jump,hop,leap"

扩展可以应用在索引或查询的时候。每个方面都有优点
(⬆)︎ 和缺点 (⬇)︎。 何时使用归结为性能与灵活性。

[options="header",cols="h,d,d"]
|===================================================
|                   | 索引             | 查询

| 索引的大小        |
      ⬇︎ 大指标因为所有同义词必须被索引。|
      ⬆︎ 正常。

| 关联         |
      ⬇︎ 所有同义词都有相同的 IDF (参见 <<relevance-intro>>)，这意味着更多常用的单词将会产生有相同的重量、不常用的单词。|
      ⬆︎ T每个同义词 IDF 将是正确的。

| 性能 |
      ⬆︎ 查询只需要找到查询字符串中指定单个词项。|
      ⬇︎ 对一个词项的查询重写来查找所有的同义词，从而降低性能。

| 灵活性       |
      ⬇︎ 同义词规则不能改变现有的文件。对于有影响的新规则，现有的文件都要重建。|
      ⬆︎ 同义词规则可以更新不需要索引文件。
|===================================================

[[synonyms-contraction]]
==== 简单的收缩

_简单的收缩_ 映射一组 ((("synonyms", "expanding or contracting", "simple contraction")))((("simple contraction (synonyms)"))) 左侧的同义词到右边的一个单一值：

    "leap,hop => jump"

它必须应用在索引或者查询的时候，以确保查询条件映射到在索引中存在的相同的单个值。

这种方法相对于简单的扩展方法有一些优点也有一些缺点相比：

索引的大小::

⬆︎ 索引大小是正常的，因为只有一个单一的词项索引。

关联::

⬇︎ 所有词项的 IDF 是一样的，所以你不能区分比较常用的词、不常用的单词。

性能::

⬆︎ 查询只需要在索引中找到单词的出现。

灵活性::
+
--

⬆︎ 新同义词可以添加到规则的左侧并应用到查询的时候。例如，我们想添加 `绑定` 到先前指定的规则这个词。下面的规则将用于包含 `绑定` 的查询或包含 `绑定` 的新添加的文档的查询：

    "leap,hop,bound => jump"

但是我们可以扩大的影响也考虑 _现有_ 文档 `包含` 绑定通过编写规则如下:

    "leap,hop,bound => jump,bound"

当你重建索引文件，你可以恢复到以前的规则来获得查询单个词项的性能优势。

--

[[synonyms-genres]]
==== 类型的扩展

类型的扩展是完全不同于简单的收缩 ((("synonyms", "expanding or contracting", "genre expansion")))((("genre expansion (synonyms)"))) 或扩张。
不是平等对待所有的同义词，类型的扩展扩大了词的意义更为通用。以这些规则为例：

    "cat    => cat,pet",
    "kitten => kitten,cat,pet",
    "dog    => dog,pet"
    "puppy  => puppy,dog,pet"

通过在索引的时候应用类型的扩展：

* 一个关于 `kitten` 的查询会发现关于 kittens 的文件。
* 查询一个 `cat` 会找到关于 kittens 和 cats 的文件。
* 一个 `pet` 的查询将发现有关的 kittens、cats、puppies、dogs 或者 pets 的文件。

另外，通过应用在查询时候的类型扩展，一个查询的 `kitten` 将扩大到返回的文件，提到的 kittens、cats、puppies、dogs。

您也可以有最好的两个世界通过应用在索引的时候扩展，以确保类型是在索引中存在。然后，在查询的时候，
你可以选择不适用于同义词（使一个 `kitten` 查询只返回 kittens 的文件）或应用同义词，以匹配 kittens、cats、pets（包括犬品种）。

前面的示例规则，对 `kitten` 的 IDF 将是正确的，而 `cat` 和 `pet` 的 IDF 然而, 这对你的工作--一个类型的扩展查询的 `kitten OR cat OR pet` 排名文件 `kitten` 最高，其次是 `cat` 的文件， `pet` 的文件将是正确的在底部。
